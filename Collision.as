package {	import flash.display.MovieClip;	import flash.geom.Point;		public class Collision	//1.0 (October 24, 2012)	{		public function Collision()		{		}				//Block objects		static public function block(objectA:MovieClip, objectB:MovieClip):void		{			var objectA_Halfwidth:Number = objectA.width / 2;			var objectA_Halfheight:Number = objectA.height / 2;			var objectB_Halfwidth:Number = objectB.width / 2;			var objectB_Halfheight:Number = objectB.height / 2;			var dx:Number = objectB.x - objectA.x;			var ox:Number = objectB_Halfwidth + objectA_Halfwidth - Math.abs(dx);						if (ox > 0)			{				var dy:Number = objectA.y - objectB.y;				var oy:Number = objectB_Halfheight + objectA_Halfheight - Math.abs(dy);				if (oy > 0)				{					if (ox < oy && oy > 4)					{						if (dx < 0)						{							//Collision on right							oy = 0;							//trace("Collision - Right (", objectB.name, ")");						}						else						{							//Collision on left							oy = 0;							ox *= -1;							//trace("Collision - Left (", objectB.name, ")");						}					}					else					{						if (dy < 0)						{							//Collision on Top							ox = 0;							oy *= -1;							objectA._vy = 0;							//trace("Collision - Top (", objectB.name, ")");						}						else						{							//Collision on Bottom							ox = 0;							//trace("Collision - Bottom (", objectB.name, ")");							objectA._vy = 0;						}					}										//Use the calculated x and y overlaps to 					//Move objectA out of the collision					objectA.x += ox;					objectA.y += oy;				}			}		}		static public function fluidBoundaries(player:MovieClip, scene:MovieClip):void		{			var player_X:Number = player.localToGlobal(new Point()).x;			var player_Y:Number = player.localToGlobal(new Point()).y;						if (player_X < Main.halfStageWidth - 1)			{				player.x += .07*(Main.halfStageWidth - player_X);				scene.x += .07*(Main.halfStageWidth - player_X);			}			else if (player_X > Main.halfStageWidth + 1)			{				player.x += .07*(Main.halfStageWidth - player_X);				scene.x += .07*(Main.halfStageWidth - player_X);			}			if (player_Y < Main.halfStageHeight - 1)			{				player.y += .07*(Main.halfStageHeight - player_Y);				scene.y += .07*(Main.halfStageHeight - player_Y);			}			else if (player_Y > Main.halfStageHeight + 1)			{				player.y += .07*(Main.halfStageHeight - player_Y);				scene.y += .07*(Main.halfStageHeight - player_Y);			}			farBackground(Main.currentObject.bg, scene)		}					static public function boundaries(player:MovieClip, scene:MovieClip):void //not used		{			//move scene and background if player goes in first or last quarter of stage			var player_Halfwidth:Number = player.width / 2;			var player_Halfheight:Number = player.height / 2;			//move scene if possible			if (player.x < (200) +  player_Halfwidth)			{				scene.x += (200) +  player_Halfwidth - player.x;				if (scene.x < 0)				{					player.x = (200) +  player_Halfwidth;				}				else if (player.x <  player_Halfwidth)				{					scene.x = 0;					player.x =  player_Halfwidth;				}				else				{					scene.x = 0;				}				farBackground(Main.currentObject.bg, scene);			}			else if (player.x > (600) -  player_Halfwidth)			{				scene.x += (600) -  player_Halfwidth - player.x;				if (scene.x > 800 - scene.width)				{					player.x = (600) -  player_Halfwidth;				}				else if (player.x >  800 - player_Halfwidth)				{					scene.x = 800 - scene.width;					player.x =  800 - player_Halfwidth;				}				else				{					scene.x = 800 - scene.width;				}				farBackground(Main.currentObject.bg, scene);			}			if (player.y < player_Halfheight)			{				player.y = player_Halfheight;			}			else if (player.y > 480 - player_Halfheight)			{				player.y = 480 - player_Halfheight;			}		}		static public function farBackground(bg:MovieClip, scene:MovieClip):void		{			var newX:Number = scene.localToGlobal(new Point()).x * .2;			bg.x = newX;			if (bg.x > 0)			{				bg.x = 0			}			else if (bg.x < 800 - bg.width)			{				bg.x = 800 - bg.width			}			var newY:Number = scene.localToGlobal(new Point()).y * .2;			bg.y = newY;			if (bg.y > 0)			{				bg.y = 0			}			else if (bg.y < 800 - bg.width)			{				bg.y = 800 - bg.width			}		}				//Collisions between the player and platform		static public function playerAndPlatform(player:MovieClip, platform:MovieClip):void		{			//version 1.0 - as used in Project Competition						//This method requires the following getter and 			//setter properties in the player object:			//objectIsOnGround:Boolean, vx:Number, vy:Number, 			//bounceX:Number, bounceY:Number						//Decalre variables needed for the player's			//position and dimensions			var player_Halfwidth:Number;			var player_Halfheight:Number;			var player_X:Number;			var player_Y:Number						//Decalre variables needed for the physics calculations			//var bounceX:Number;			//var bounceY:Number;			//var frictionX:Number;			//var frictionY:Number;						//Find out whether the player object has a collisionArea			//subobject defined			if(player.collisionArea != null)			{				//If it does, find out its width and height				player_Halfwidth = player.collisionArea.width / 2;			    player_Halfheight = player.collisionArea.height / 2;								//Convert the collisionArea's local x,y coordinates to global coordinates            	player_X = player.collisionArea.localToGlobal(new Point()).x;				player_Y = player.collisionArea.localToGlobal(new Point()).y;			}			else			{				trace("collision -> no player.collisionArea");				//If there's no collisionArea subobject				//Use the player's main height, width, x and y				player_Halfwidth = player.width / 2;			    player_Halfheight = player.height / 2;				player_X = player.x;				player_Y = player.y;			}			//Find the platform's dimensions			var platform_x:Number = platform.localToGlobal(new Point()).x;			var platform_y:Number = platform.localToGlobal(new Point()).y;			var platform_Halfwidth:Number = platform.width / 2;			var platform_Halfheight:Number = platform.height / 2;						//Find the distance between the player and platfrom on the x axis			var dx:Number = platform_x - player_X;						//Find the amount of overlap on the x axis			var ox:Number = platform_Halfwidth + player_Halfwidth - Math.abs(dx);						//Check for a collision on the x axis			if (ox > 0)			{				//If the objects overlap on the x axis, a collision might be occuring				//Define the variables you need to check for a collision on the y axis				var dy:Number = player_Y - platform_y;				var oy:Number = platform_Halfheight + player_Halfheight - Math.abs(dy);								//Check for a y axis collision. We know a collision must be				//occuring if there's a collision on both the x and y axis				if (oy > 0)				{					//Yes, a collision is occuring! 					//Now you need to find out on which side 					//of the platform it's occuring on.					if (ox < oy && oy > Main.gravityVar)					{						if (dx < 0)						{							//Collision on right							oy = 0;							dx = 1;							dy = 0;						}						else						{							//Collision on left							oy = 0;							ox *= -1;							dx = -1;							dy = 0;						}					}					else if (ox > oy && ox > Main.speedVar)					{						if (dy < 0)						{							//Collision on Top							ox = 0;							oy *= -1;							dx = 0;							dy = -1;							if (player._vy > 0)							{								player._vy = 0;							}							player.canJump = true;						}						else						{							//Collision on Bottom							if (player._vy < 0)							{								player._vy = 0;							}							ox = 0;							dx = 0;							dy = 1;						}					}										//Find the direction of the collision ("dot product")					//var directionOfCollision:Number = player._vx * dx + player._vy * dy;										//Calculate the new direction for the bounce ("projection")					//var newDirection_X:Number = directionOfCollision * dx;					//var newDirection_Y:Number = directionOfCollision * dy;										//Find the "tangent velocity":					//the speed in the direction that the object is moving.					//It's used for calculating additional platform friction.					//var tangent_Vx:Number = player._vx - newDirection_X;					//var tangent_Vy:Number = player._vy - newDirection_Y;										//Apply collision forces if the object is moving into a collision					//if (directionOfCollision < 0)					//{						//Calculate the friction						//frictionX = tangent_Vx * friction;						//frictionY = tangent_Vy * friction;												//Calculate the amount of bounce						//bounceX = newDirection_X * bounce;						//bounceY = newDirection_Y * bounce;					//}					//else					//{						//Prevent forces from being applied if the object is						//moving out of a collision						//bounceX = 0;						//bounceY = 0;						//frictionX = 0;						//frictionY = 0;					//}					//Apply platform friction					//player._vx += ox //- frictionX;					//player._vy += oy //- frictionY;										//Move the player out of the collision					player.x += ox;					player.y += oy;										//Bounce the player off the platform					//player.bounceX = bounceX;					//player.bounceY = bounceY;				}			}		}		static public function bouncePlayer(objectA:MovieClip, objectB:MovieClip, multVar:Number)		{			//pushes player back when hurt			trace("bounce player called");			var objectA_Halfwidth:Number = objectA.collisionArea.width / 2;			var objectA_Halfheight:Number = objectA.collisionArea.height / 2;			var objectB_Halfwidth:Number = objectB.collisionArea.width / 2;			var objectB_Halfheight:Number = objectB.collisionArea.height / 2;			var dx:Number = objectB.localToGlobal(new Point()).x - objectA.localToGlobal(new Point()).x;			var ox:Number = objectB_Halfwidth + objectA_Halfwidth - Math.abs(dx);						if (ox > 0)			{				var dy:Number = objectA.localToGlobal(new Point()).y - objectB.localToGlobal(new Point()).y;				var oy:Number = objectB_Halfheight + objectA_Halfheight - Math.abs(dy);				if (oy > 0)				{					if (ox < oy && oy > 4)					{						if (dx < 0)						{							//Collision on right							oy = 0;							ox = 1;						}						else						{							//Collision on left							oy = 0;							ox = -1;						}					}					else					{						if (dy < 0)						{							//Collision on Top							ox = 0;							oy *= -1;							objectA._vy = 0;						}						else						{							//Collision on Bottom							ox = 0;							objectA._vy = 0;						}					}										//Use the calculated x and y overlaps to 					//Move objectA out of the collision					objectA.x += multVar*ox;				}			}		}		static public function roamerAndPlatform(roamer:MovieClip, platform:MovieClip):void		{			//based on player and platform 1.0			var roamer_Halfwidth:Number;			var roamer_Halfheight:Number;			var roamer_X:Number;			var roamer_Y:Number									if(roamer.collisionArea != null)			{				roamer_Halfwidth = roamer.collisionArea.width / 2;			    roamer_Halfheight = roamer.collisionArea.height / 2;            	roamer_X = roamer.collisionArea.localToGlobal(new Point()).x;				roamer_Y = roamer.collisionArea.localToGlobal(new Point()).y;			}			else			{				trace("collision -> no roamer.collisionArea on", roamer.name);				roamer_Halfwidth = roamer.width / 2;			    roamer_Halfheight = roamer.height / 2;				roamer_X = roamer.x;				roamer_Y = roamer.y;			}			var platform_x:Number = platform.localToGlobal(new Point()).x;			var platform_y:Number = platform.localToGlobal(new Point()).y;			var platform_Halfwidth:Number = platform.width / 2;			var platform_Halfheight:Number = platform.height / 2;						var dx:Number = platform_x - roamer_X;									var ox:Number = platform_Halfwidth + roamer_Halfwidth - Math.abs(dx);									if (ox > 0)			{				var dy:Number = roamer_Y - platform_y;				var oy:Number = platform_Halfheight + roamer_Halfheight - Math.abs(dy);								if (oy > 0)				{					if (ox < oy && oy > Main.gravityVar)					{						if (dx < 0)						{							//Collision on right							oy = 0;							dx = 1;							dy = 0;							roamer._vx *= -1;							roamer.scaleX = -roamer.scaleX;						}						else if (oy > Main.gravityVar)						{							//Collision on left							oy = 0;							ox *= -1;							dx = -1;							dy = 0;							roamer._vx *= -1;							roamer.scaleX = -roamer.scaleX;						}						else						{							oy = 0;							ox = 0;						}					}					else if (ox > oy && ox > 0.4*Main.speedVar)					{						if (dy < 0)						{							//Collision on top							ox = 0;							oy *= -1;							dx = 0;							dy = -1;							roamer._vy = 0;							roamer.gravity = 0;						}						else						{							//Collision on bottom							roamer._vy = 0;							ox = 0;							dx = 0;							dy = 1;						}					}					roamer.x += ox;					roamer.y += oy;				}			}		}		static public function lightUpThatGoalKid(kid:MovieClip, goal:MovieClip):void		{			//based on player and platform 1.0			var goal_LightHalfWidth:Number;			var goal_LightHalfHeight:Number;			var goal_HalfWidth:Number;			var goal_HalfHeight:Number;			var goal_x;			var goal_y;			var kid_Halfwidth:Number;			var kid_Halfheight:Number;			var kid_x:Number;			var kid_y:Number						if(goal.glowArea != null)			{				goal_LightHalfWidth = goal.glowArea.width / 2;				goal_LightHalfHeight = goal.glowArea.height / 2;			    goal_HalfWidth = goal.collisionArea.width / 2;            	goal_x = goal.glowArea.localToGlobal(new Point()).x;				goal_y = goal.glowArea.localToGlobal(new Point()).y;			}			else			{				trace("Collision.as: no goal.glowArea on", goal.name);				return;			}			kid_x = kid.localToGlobal(new Point()).x;			kid_y = kid.localToGlobal(new Point()).y;			kid_Halfwidth = kid.width / 2;			kid_Halfheight = kid.height / 2;						var dx:Number = goal_x - kid_x;									var ox_Light:Number = goal_LightHalfWidth + kid_Halfwidth - Math.abs(dx);									if (ox_Light > 0)			{				var dy:Number = kid_y - goal_y;				var oy:Number = goal_LightHalfHeight + kid_Halfheight - Math.abs(dy);				if (oy > 0)				{					//Collision!					if (kid.myHighKid) {						MovieClip(kid.myHighKid).alpha = ox_Light / (goal_LightHalfWidth);					}				}			}		}	}}